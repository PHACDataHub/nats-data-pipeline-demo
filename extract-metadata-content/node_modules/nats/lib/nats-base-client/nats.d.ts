import { ProtocolHandler } from "./protocol";
import { ConnectionOptions, JetStreamClient, JetStreamManager, JetStreamOptions, Msg, NatsConnection, PublishOptions, RequestManyOptions, RequestOptions, ServerInfo, Stats, Status, Subscription, SubscriptionOptions } from "./types";
import type { SemVer } from "./semver";
import { Features } from "./semver";
import { QueuedIterator } from "./queued_iterator";
export declare class NatsConnectionImpl implements NatsConnection {
    options: ConnectionOptions;
    protocol: ProtocolHandler;
    draining: boolean;
    listeners: QueuedIterator<Status>[];
    private constructor();
    static connect(opts?: ConnectionOptions): Promise<NatsConnection>;
    closed(): Promise<void | Error>;
    close(): Promise<void>;
    _check(subject: string, sub: boolean, pub: boolean): void;
    publish(subject: string, data?: Uint8Array, options?: PublishOptions): void;
    subscribe(subject: string, opts?: SubscriptionOptions): Subscription;
    _resub(s: Subscription, subject: string, max?: number): void;
    requestMany(subject: string, data?: Uint8Array, opts?: Partial<RequestManyOptions>): Promise<QueuedIterator<Msg | Error>>;
    request(subject: string, data?: Uint8Array, opts?: RequestOptions): Promise<Msg>;
    /** *
     * Flushes to the server. Promise resolves when round-trip completes.
     * @returns {Promise<void>}
     */
    flush(): Promise<void>;
    drain(): Promise<void>;
    isClosed(): boolean;
    isDraining(): boolean;
    getServer(): string;
    status(): AsyncIterable<Status>;
    get info(): ServerInfo | undefined;
    stats(): Stats;
    jetstreamManager(opts?: JetStreamOptions): Promise<JetStreamManager>;
    jetstream(opts?: JetStreamOptions): JetStreamClient;
    getServerVersion(): SemVer | undefined;
    rtt(): Promise<number>;
    get features(): Features;
}
