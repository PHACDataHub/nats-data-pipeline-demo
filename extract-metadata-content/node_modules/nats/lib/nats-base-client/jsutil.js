"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkJsErrorCode = exports.isTerminal409 = exports.setMaxWaitingToFail = exports.Js409Errors = exports.checkJsError = exports.newJsErrorMsg = exports.isHeartbeatMsg = exports.isFlowControlMsg = exports.millis = exports.nanos = exports.defaultConsumer = exports.validName = exports.validateName = exports.validateStreamName = exports.validateDurableName = void 0;
/*
 * Copyright 2021-2022 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const types_1 = require("./types");
const error_1 = require("./error");
const headers_1 = require("./headers");
const msg_1 = require("./msg");
function validateDurableName(name) {
    return validateName("durable", name);
}
exports.validateDurableName = validateDurableName;
function validateStreamName(name) {
    return validateName("stream", name);
}
exports.validateStreamName = validateStreamName;
function validateName(context, name = "") {
    if (name === "") {
        throw Error(`${context} name required`);
    }
    const m = validName(name);
    if (m.length) {
        throw new Error(`invalid ${context} name - ${context} name ${m}`);
    }
}
exports.validateName = validateName;
function validName(name = "") {
    if (name === "") {
        throw Error(`name required`);
    }
    const bad = [".", "*", ">"];
    for (let i = 0; i < bad.length; i++) {
        const v = bad[i];
        if (name.indexOf(v) !== -1) {
            return `cannot contain '${v}'`;
        }
    }
    return "";
}
exports.validName = validName;
function defaultConsumer(name, opts = {}) {
    return Object.assign({
        name: name,
        deliver_policy: types_1.DeliverPolicy.All,
        ack_policy: types_1.AckPolicy.Explicit,
        ack_wait: nanos(30 * 1000),
        replay_policy: types_1.ReplayPolicy.Instant,
    }, opts);
}
exports.defaultConsumer = defaultConsumer;
/**
 * Converts the specified millis into Nanos
 * @param millis
 */
function nanos(millis) {
    return millis * 1000000;
}
exports.nanos = nanos;
/**
 * Convert the specified Nanos into millis
 * @param ns
 */
function millis(ns) {
    return Math.floor(ns / 1000000);
}
exports.millis = millis;
/**
 * Returns true if the message is a flow control message
 * @param msg
 */
function isFlowControlMsg(msg) {
    if (msg.data.length > 0) {
        return false;
    }
    const h = msg.headers;
    if (!h) {
        return false;
    }
    return h.code >= 100 && h.code < 200;
}
exports.isFlowControlMsg = isFlowControlMsg;
/**
 * Returns true if the message is a heart beat message
 * @param msg
 */
function isHeartbeatMsg(msg) {
    var _a;
    return isFlowControlMsg(msg) && ((_a = msg.headers) === null || _a === void 0 ? void 0 : _a.description) === "Idle Heartbeat";
}
exports.isHeartbeatMsg = isHeartbeatMsg;
function newJsErrorMsg(code, description, subject) {
    const h = (0, headers_1.headers)(code, description);
    const arg = { hdr: 1, sid: 0, size: 0 };
    const msg = new msg_1.MsgImpl(arg, types_1.Empty, {});
    msg._headers = h;
    msg._subject = subject;
    return msg;
}
exports.newJsErrorMsg = newJsErrorMsg;
function checkJsError(msg) {
    // JS error only if no payload - otherwise assume it is application data
    if (msg.data.length !== 0) {
        return null;
    }
    const h = msg.headers;
    if (!h) {
        return null;
    }
    return checkJsErrorCode(h.code, h.description);
}
exports.checkJsError = checkJsError;
var Js409Errors;
(function (Js409Errors) {
    Js409Errors["MaxBatchExceeded"] = "exceeded maxrequestbatch of";
    Js409Errors["MaxExpiresExceeded"] = "exceeded maxrequestexpires of";
    Js409Errors["MaxBytesExceeded"] = "exceeded maxrequestmaxbytes of";
    Js409Errors["MaxMessageSizeExceeded"] = "message size exceeds maxbytes";
    Js409Errors["PushConsumer"] = "consumer is push based";
    Js409Errors["MaxWaitingExceeded"] = "exceeded maxwaiting";
    Js409Errors["IdleHeartbeatMissed"] = "`idle heartbeats missed`";
})(Js409Errors = exports.Js409Errors || (exports.Js409Errors = {}));
let MAX_WAITING_FAIL = false;
function setMaxWaitingToFail(tf) {
    MAX_WAITING_FAIL = tf;
}
exports.setMaxWaitingToFail = setMaxWaitingToFail;
function isTerminal409(err) {
    if (err.code !== error_1.ErrorCode.JetStream409) {
        return false;
    }
    const fatal = [
        Js409Errors.MaxBatchExceeded,
        Js409Errors.MaxExpiresExceeded,
        Js409Errors.MaxBytesExceeded,
        Js409Errors.MaxMessageSizeExceeded,
        Js409Errors.PushConsumer,
        Js409Errors.IdleHeartbeatMissed,
    ];
    if (MAX_WAITING_FAIL) {
        fatal.push(Js409Errors.MaxWaitingExceeded);
    }
    return fatal.find((s) => {
        return err.message.indexOf(s) !== -1;
    }) !== undefined;
}
exports.isTerminal409 = isTerminal409;
function checkJsErrorCode(code, description = "") {
    if (code < 300) {
        return null;
    }
    description = description.toLowerCase();
    switch (code) {
        case 404:
            // 404 for jetstream will provide different messages ensure we
            // keep whatever the server returned
            return new error_1.NatsError(description, error_1.ErrorCode.JetStream404NoMessages);
        case 408:
            return new error_1.NatsError(description, error_1.ErrorCode.JetStream408RequestTimeout);
        case 409: {
            // the description can be exceeded max waiting or max ack pending, which are
            // recoverable, but can also be terminal errors where the request exceeds
            // some value in the consumer configuration
            const ec = description.startsWith(Js409Errors.IdleHeartbeatMissed)
                ? error_1.ErrorCode.JetStreamIdleHeartBeat
                : error_1.ErrorCode.JetStream409;
            return new error_1.NatsError(description, ec);
        }
        case 503:
            return error_1.NatsError.errorForCode(error_1.ErrorCode.JetStreamNotEnabled, new Error(description));
        default:
            if (description === "") {
                description = error_1.ErrorCode.Unknown;
            }
            return new error_1.NatsError(description, `${code}`);
    }
}
exports.checkJsErrorCode = checkJsErrorCode;
//# sourceMappingURL=jsutil.js.map