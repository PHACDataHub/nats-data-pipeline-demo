import { callbackFn, ConsumerConfig, JetStreamClient, JetStreamManager, JsMsg, KV, KvCodec, KvCodecs, KvEntry, KvOptions, KvPutOptions, KvRemove, KvStatus, Placement, PurgeOpts, PurgeResponse, Republish, StorageType, StoredMsg, StreamInfo } from "./types";
import { QueuedIterator } from "./queued_iterator";
import { MsgHdrs } from "./headers";
export declare function Base64KeyCodec(): KvCodec<string>;
export declare function NoopKvCodecs(): KvCodecs;
export declare function defaultBucketOpts(): Partial<KvOptions>;
export declare const kvOperationHdr = "KV-Operation";
export declare const kvPrefix = "KV_";
export declare function validateKey(k: string): void;
export declare function validateSearchKey(k: string): void;
export declare function hasWildcards(k: string): boolean;
export declare function validateBucket(name: string): void;
export declare class Bucket implements KV, KvRemove {
    jsm: JetStreamManager;
    js: JetStreamClient;
    stream: string;
    bucket: string;
    direct: boolean;
    codec: KvCodecs;
    prefix: string;
    editPrefix: string;
    useJsPrefix: boolean;
    _prefixLen: number;
    constructor(bucket: string, jsm: JetStreamManager, js: JetStreamClient);
    static create(js: JetStreamClient, name: string, opts?: Partial<KvOptions>): Promise<KV>;
    static bind(js: JetStreamClient, name: string, opts?: Partial<{
        codec: KvCodecs;
    }>): Promise<KV>;
    init(opts?: Partial<KvOptions>): Promise<void>;
    initializePrefixes(info: StreamInfo): void;
    bucketName(): string;
    subjectForBucket(): string;
    subjectForKey(k: string, edit?: boolean): string;
    fullKeyName(k: string): string;
    get prefixLen(): number;
    encodeKey(key: string): string;
    decodeKey(ekey: string): string;
    validateKey: typeof validateKey;
    validateSearchKey: typeof validateSearchKey;
    hasWildcards: typeof hasWildcards;
    close(): Promise<void>;
    dataLen(data: Uint8Array, h?: MsgHdrs): number;
    smToEntry(sm: StoredMsg): KvEntry;
    jmToEntry(jm: JsMsg): KvEntry;
    create(k: string, data: Uint8Array): Promise<number>;
    update(k: string, data: Uint8Array, version: number): Promise<number>;
    put(k: string, data: Uint8Array, opts?: Partial<KvPutOptions>): Promise<number>;
    get(k: string, opts?: {
        revision: number;
    }): Promise<KvEntry | null>;
    purge(k: string): Promise<void>;
    delete(k: string): Promise<void>;
    purgeDeletes(olderMillis?: number): Promise<PurgeResponse>;
    _deleteOrPurge(k: string, op: "DEL" | "PURGE"): Promise<void>;
    _doDeleteOrPurge(k: string, op: "DEL" | "PURGE"): Promise<void>;
    _buildCC(k: string, history?: boolean, opts?: Partial<ConsumerConfig>): Partial<ConsumerConfig>;
    remove(k: string): Promise<void>;
    history(opts?: {
        key?: string;
        headers_only?: boolean;
    }): Promise<QueuedIterator<KvEntry>>;
    watch(opts?: {
        key?: string;
        headers_only?: boolean;
        initializedFn?: callbackFn;
    }): Promise<QueuedIterator<KvEntry>>;
    keys(k?: string): Promise<QueuedIterator<string>>;
    purgeBucket(opts?: PurgeOpts): Promise<PurgeResponse>;
    destroy(): Promise<boolean>;
    status(): Promise<KvStatus>;
}
export declare class KvStatusImpl implements KvStatus {
    si: StreamInfo;
    cluster: string;
    constructor(si: StreamInfo, cluster?: string);
    get bucket(): string;
    get values(): number;
    get history(): number;
    get ttl(): number;
    get bucket_location(): string;
    get backingStore(): StorageType;
    get storage(): StorageType;
    get replicas(): number;
    get description(): string;
    get maxBucketSize(): number;
    get maxValueSize(): number;
    get max_bytes(): number;
    get placement(): Placement;
    get placementCluster(): string;
    get republish(): Republish;
    get streamInfo(): StreamInfo;
    get size(): number;
}
