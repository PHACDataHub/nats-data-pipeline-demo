"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.credsAuthenticator = exports.jwtAuthenticator = exports.nkeyAuthenticator = exports.tokenAuthenticator = exports.usernamePasswordAuthenticator = exports.noAuthFn = exports.buildAuthenticator = void 0;
/*
 * Copyright 2020-2022 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nkeys_1 = require("./nkeys");
const encoders_1 = require("./encoders");
const error_1 = require("./error");
function buildAuthenticator(opts) {
    // jwtAuthenticator is created by the user, since it
    // will require possibly reading files which
    // some of the clients are simply unable to do
    if (opts.authenticator) {
        return opts.authenticator;
    }
    if (opts.token) {
        return tokenAuthenticator(opts.token);
    }
    if (opts.user) {
        return usernamePasswordAuthenticator(opts.user, opts.pass);
    }
    return noAuthFn();
}
exports.buildAuthenticator = buildAuthenticator;
function noAuthFn() {
    return () => {
        return;
    };
}
exports.noAuthFn = noAuthFn;
/**
 * Returns a user/pass authenticator for the specified user and optional password
 * @param { string }user
 * @param {string } pass
 * @return {UserPass}
 */
function usernamePasswordAuthenticator(user, pass) {
    return () => {
        return { user, pass };
    };
}
exports.usernamePasswordAuthenticator = usernamePasswordAuthenticator;
/**
 * Returns a token authenticator for the specified token
 * @param { string } token
 * @return {TokenAuth}
 */
function tokenAuthenticator(token) {
    return () => {
        return { auth_token: token };
    };
}
exports.tokenAuthenticator = tokenAuthenticator;
/**
 * Returns an Authenticator that returns a NKeyAuth based that uses the
 * specified seed or function returning a seed.
 * @param {Uint8Array | (() => Uint8Array)} seed - the nkey seed
 * @return {NKeyAuth}
 */
function nkeyAuthenticator(seed) {
    return (nonce) => {
        seed = typeof seed === "function" ? seed() : seed;
        const kp = seed ? nkeys_1.nkeys.fromSeed(seed) : undefined;
        const nkey = kp ? kp.getPublicKey() : "";
        const challenge = encoders_1.TE.encode(nonce || "");
        const sigBytes = kp !== undefined && nonce ? kp.sign(challenge) : undefined;
        const sig = sigBytes ? nkeys_1.nkeys.encode(sigBytes) : "";
        return { nkey, sig };
    };
}
exports.nkeyAuthenticator = nkeyAuthenticator;
/**
 * Returns an Authenticator function that returns a JwtAuth.
 * If a seed is provided, the public key, and signature are
 * calculated.
 *
 * @param {string | ()=>string} ajwt - the jwt
 * @param {Uint8Array | ()=> Uint8Array } seed - the optional nkey seed
 * @return {Authenticator}
 */
function jwtAuthenticator(ajwt, seed) {
    return (nonce) => {
        const jwt = typeof ajwt === "function" ? ajwt() : ajwt;
        const fn = nkeyAuthenticator(seed);
        const { nkey, sig } = fn(nonce);
        return { jwt, nkey, sig };
    };
}
exports.jwtAuthenticator = jwtAuthenticator;
/**
 * Returns an Authenticator function that returns a JwtAuth.
 * This is a convenience Authenticator that parses the
 * specifid creds and delegates to the jwtAuthenticator.
 * @param {Uint8Array} creds - the contents of a creds file
 * @returns {JwtAuth}
 */
function credsAuthenticator(creds) {
    const CREDS = /\s*(?:(?:[-]{3,}[^\n]*[-]{3,}\n)(.+)(?:\n\s*[-]{3,}[^\n]*[-]{3,}\n))/ig;
    const s = encoders_1.TD.decode(creds);
    // get the JWT
    let m = CREDS.exec(s);
    if (!m) {
        throw error_1.NatsError.errorForCode(error_1.ErrorCode.BadCreds);
    }
    const jwt = m[1].trim();
    // get the nkey
    m = CREDS.exec(s);
    if (!m) {
        throw error_1.NatsError.errorForCode(error_1.ErrorCode.BadCreds);
    }
    const seed = encoders_1.TE.encode(m[1].trim());
    return jwtAuthenticator(jwt, seed);
}
exports.credsAuthenticator = credsAuthenticator;
//# sourceMappingURL=authenticator.js.map